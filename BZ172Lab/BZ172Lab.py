"""
The main purpose of having this simple script is to be more familiar with data
processing with pandas and the side effect is having a 'tool' to convert the
two DDF files generated by M172 IDE into one modbus register map file by csv
format which is easy to be imported in excel.

Version MY_VERSION

2021.02.17 First created
2021.02.21 Create separate files for register map doc and code generation
2021.02.27 Add the data points accessor to the target device
2021.02.28 New verison of c file generation
2021.03.01 Implementation of the six data point representors
           Improve the C files by adding comments
           Addresses the issues in the C files that cause failure of modbus polling

"""

import pandas as pd
from ctypes import *
import os
from datetime import datetime

MY_VERSION = '21MAR01'

def createDDF(variable_filename, e2prom_filename) :
    '''
    Parameters
    ----------
    variable_filename : TYPE
        DESCRIPTION.
    e2prom_filename : TYPE
        DESCRIPTION.

    Returns
    -------
    None.

    '''
    # load sheets
    dfVariables = pd.read_csv(variable_filename,
                              encoding='ansi',
                              dtype=str,
                              delimiter=',',
                              usecols=[0, 1, 3, 5, 6, 7, 8, 11, 14, 15, 16])
    dfConfigurations = pd.read_csv(e2prom_filename,
                                   encoding='ansi',
                                   dtype=str,
                                   usecols=[0, 1, 3, 5, 6, 7, 8, 11, 14, 15])

    # Add 'RW' to dfConfigurations
    ReadOnly = ['RW'] * len(dfConfigurations)
    dfConfigurations.insert(loc=9, column='ReadOnly', value=ReadOnly)

    # Combine the two dataframes and replace 'na' with blank
    ddf = pd.concat([dfVariables, dfConfigurations])
    ddf = ddf.fillna('')

    # Remove 'BZ...' items
    ddf = ddf.drop(index=ddf[ddf['Name'].str.match('BZ')].index)

    # Fill the 'Size' of 16bit items with '1'
    ddf.loc[ddf['Size'] == '', 'Size'] = '1'

    # Remove 'bz' and 'Cfg' from names
    ddf.Name = ddf.Name.str.replace('bz', '')
    ddf.Min = ddf.Min.str.replace('bz', '')
    ddf.Max = ddf.Max.str.replace('bz', '')

    # Sort by address
    ddf.loc[:, 'Address'] = ddf.Address.astype('ushort')
    ddf = ddf.sort_values(by='Address', ascending=True)

    # Update column names
    ddf.columns = ['Address', 'DataPoint', 'Type', 'Size', 'Default', 'Min',
                   'Max', 'Unit', 'RW', 'Description', 'Note']

    # Update index
    ddf.index=[x for x in range(1, len(ddf) + 1)]

    # save to csv file with utf-8 format by default
    ddf.to_csv('BZ172LabDDF.csv', index_label='NO')

    return ddf;

def createbzMBDevice_BZ172Lab(ddf) :
    with open("bzMBDevice_BZ172Lab.h", "w") as file:
        strContent = """
/**
 * This file is generated by BZ172Lab.py ({0}) according to the DDF file.
 *
 * DON'T CHANGE IT MANUALLY!
 *
 * {1} created.
 */
#ifndef _BZMBDEVICE_BZ172LAB_H_
#define _BZMBDEVICE_BZ172LAB_H_

#ifdef __cplusplus
extern "C" {{
#endif // __cplusplus

#include "bzObject.h"
#include "bzMBDevice.h"

typedef struct _tagMBBZ172LabVariables {{

""".format(MY_VERSION, str(datetime.now()))
        for i in range(0, len(ddf) - 1):
            if (ddf.Type.iloc[i] == 'Signed 16-bit') :
                strContent += '    /*{0:03d}*/bzI16 '.format(i) + ddf.DataPoint.iloc[i] + '[1];'
            elif (ddf.Type.iloc[i] == 'Unsigned 16-bit'):
                strContent += '    /*{0:03d}*/bzU16 '.format(i) + ddf.DataPoint.iloc[i] + '[1];'
            elif (ddf.Type.iloc[i] == 'String') :
                max_len = int(int(ddf.Size.iloc[i]) / 2)
                #if (max_len % 2) :
                #    max_len += 1
                #else :
                #    max_len += 2
                strContent += str('    /*{0:03d}*/bzU8  ' + ddf.DataPoint.iloc[i] +
                              '[{1}];').format(i, max_len)
            else:
                pass
            if (ddf.Type.iloc[i] == 'String'):
                strContent += '// Max string length is ' + str(max_len) + '\n'
            else:
                if (ddf.Unit.iloc[i] == ''):
                    strContent += '// ' + ddf.Note.iloc[i] + '\n'
                else:
                    strContent += '// ' + ddf.Unit.iloc[i] + '\n'
                
        strContent += """
} MBBZ172LabVariables;
"""

        strContent += '\n#define MAX_BZ172LAB_MB_REGISTERS {0}\n'.format(len(ddf))

        strContent += """
typedef void (*BZ172LabDatapointRepresentor) (bzR32* /*rval*/,
                                              bzBool /*from_reg*/,
                                              bzU16* /*reg*/,
                                              bzU8 /*len*/);

typedef struct _tagMBBZ172LabDevice {
    MBBZ172LabVariables             MBVariables;
    bzModbusRegister                MBRegisters[MAX_BZ172LAB_MB_REGISTERS];
    BZ172LabDatapointRepresentor    Representors[MAX_BZ172LAB_MB_REGISTERS];
    bzModbusDevice                  Dev;
} MBBZ172LabDevice;

_public_ void MBBZ172LabDevice_ctor(MBBZ172LabDevice*, bzU8);
_public_ void MBBZ172LabDevice_dtor(MBBZ172LabDevice*);


#ifdef __cplusplus
}
#endif

#endif  // _BZMBDEVICE_BZ172LAB_H_

"""
        file.write(strContent)
        file.close()

    with open("bzMBDevice_BZ172Lab.c", "w") as file:
        strRepresentorList = ["MBBZ172LabDevice_bzU16_1_scaled_cov",    # 0
                              "MBBZ172LabDevice_bzU16_10_scaled_cov",   # 1
                              "MBBZ172LabDevice_bzU16_100_scaled_cov",  # 2
                              "MBBZ172LabDevice_bzi16_1_scaled_cov",    # 3
                              "MBBZ172LabDevice_bzi16_10_scaled_cov",   # 4
                              "MBBZ172LabDevice_bzi16_100_scaled_cov"]  # 5
        strContent = """
/**
 * This file is generated by BZ172Lab.py ({0}) according to the DDF file.
 *
 * DON'T CHANGE IT MANUALLY!
 *
 * {1} created.
 */
#include "bzMBDevice_BZ172Lab.h"

void {2}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = (bzR32)regs[0];    
    }} else {{
        regs[0] = (bzU16)(*lpRval);
    }}
}}
void {3}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = ((bzR32)regs[0]) / (bzR32)10.0;    
    }} else {{
        regs[0] = (bzU16)((*lpRval) * (bzR32)10.0);
    }}
}}
void {4}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = ((bzR32)regs[0]) / (bzR32)100.0;    
    }} else {{
        regs[0] = (bzU16)((*lpRval) * (bzR32)100.0);
    }}
}}
void {5}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = (bzR32)((bzI16)regs[0]);    
    }} else {{
        regs[0] = (bzI16)(*lpRval);
    }}
}}
void {6}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = ((bzR32)((bzI16)regs[0])) / (bzR32)10.0;    
    }} else {{
        regs[0] = (bzI16)((*lpRval) * (bzR32)10.0);
    }}
}}
void {7}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = ((bzR32)((bzI16)regs[0])) / (bzR32)100.0;    
    }} else {{
        regs[0] = (bzI16)((*lpRval) * (bzR32)100.0);
    }}
}}

_public_ void MBBZ172LabDevice_ctor(MBBZ172LabDevice* me, bzU8 id) {{
""".format(MY_VERSION,
           str(datetime.now()),
           strRepresentorList[0],
           strRepresentorList[1],
           strRepresentorList[2],
           strRepresentorList[3],
           strRepresentorList[4],
           strRepresentorList[5])
        for i in range(0, len(ddf) - 1):
            if (ddf.Type.iloc[i] == 'String') :
                sz = int(int(ddf.Size.iloc[i]) / 2)
                #if (sz % 2) :
                #    sz += 1
                #else :
                #    sz += 2
                #sz /= 2
            else:
                sz = 1
            strLn = '    bzModbusRegister_new(me->MBRegisters[{0}], '\
                    'bzBusProtocol_MB_HoldingRegister, {1}, {2}, '\
                    'me->MBVariables.{3});\n'.format(i,
                                                     int(ddf.Address.iloc[i]) - 1,
                                                     int(sz),
                                                     ddf.DataPoint.iloc[i])
            strContent += strLn

            strType = ddf.Type.iloc[i]
            strScale = ddf.Unit.iloc[i]
            if (strType == 'String'):
                strRepresentor = 'bzNull'
            elif (strType == 'Signed 16-bit'):
                if (strScale.find('.1') >= 0):
                    strRepresentor = strRepresentorList[4]
                elif (strScale.find('.01') >= 0):
                    strRepresentor = strRepresentorList[5]
                else:
                    strRepresentor = strRepresentorList[3]
            elif (strType == 'Unsigned 16-bit'):
                if (strScale.find('.1') >= 0):
                    strRepresentor = strRepresentorList[1]
                elif (strScale.find('.01') >= 0):
                    strRepresentor = strRepresentorList[2]
                else:
                    strRepresentor = strRepresentorList[0]
            else:
                pass
            strLn = '    me->Representors[{0}] = {1};\n\n'.format(i,
                                                                  strRepresentor)
            strContent += strLn

        strContent += """

    bzModbusDevice_ctor(&me->Dev, id);

    me->Dev.Registers = me->MBRegisters;
    me->Dev.NumberOfRegisters = MAX_BZ172LAB_MB_REGISTERS;
}

_public_ void MBBZ172LabDevice_dtor(MBBZ172LabDevice* me) {}
"""
        file.write(strContent)
        file.close()

# %% A 'c' functions wrapper as the data points accessor
class IrACdx36LibCaller :
    def __init__(self):
        self.clib = CDLL(os.getcwd() + '\\IrACdx36Libx64.dll')

        self.clib.IRAC_Initialize.argtypes = []
        self.clib.IRAC_Initialize.restype = c_int
        self.Init = self.clib.IRAC_Initialize

        self.clib.IRAC_Terminate.argtypes = []
        self.clib.IRAC_Terminate.restype = c_int
        self.Term = self.clib.IRAC_Terminate

        self.clib.IRAC_BZ172Lab_PollVariable.argtypes = [c_int, c_int, POINTER(c_float)]
        self.clib.IRAC_BZ172Lab_PollVariable.restype = c_int
        self.pollVariable = self.clib.IRAC_BZ172Lab_PollVariable

        self.clib.IRAC_BZ172Lab_PollString.argtypes = [c_int, c_int, POINTER(c_char), c_int]
        self.clib.IRAC_BZ172Lab_PollString.restype = c_int
        self.pollString = self.clib.IRAC_BZ172Lab_PollString

    def init(self):
        self.Init()

    def term(self):
        self.Term()

    def getVar(self, id):
        val = c_float()
        rtn = self.pollVariable(id, 1, pointer(val))
        return rtn, val.value;

    def setVar(self, id, val):
        rval = c_float()
        rval.value = val;
        rtn = self.pollVariable(id, 0, pointer(rval))
        return rtn;

    def getStr(self, id):
        lpstr = create_string_buffer(b'\0', 256)
        rtn = self.pollString(id, 1, lpstr, 256)
        return rtn, lpstr.value

    def setStr(self, id, text):
        lpstr = create_string_buffer(b'\0', 256)
        lpstr.value = text.encode('utf-8')
        rtn = self.pollString(id, 0, lpstr, 256)
        return rtn;

"""
Example,

caller = IrACdx36LibCaller()

def BIOS_VER(*args)
    if (args == ()):
        rtn, val = caller.getStr(0)
        if (rtn == 0):
            rtn = val
        else:
            print("ERROR CODE:", rtn)
    else:
        rtn = caller.setStr(0, args[0])
        if (rtn != 0):
            print("ERROR CODE:", rtn)
        else:
            pass

    return rtn

def RAT(*args):
    if (args == ()):
        rtn, val = caller.getVar(3)
        if (rtn == 0):
            rtn = val
        else:
            print("ERROR CODE:", rtn)
    else:
        rtn = caller.setVar(3, args[0])
        if (rtn != 0):
            print("ERROR CODE:", rtn)
        else:
            pass

    return rtn

caller.init()
if (RAT() > 0):    # Read from a data point
    RAT(23.2)      # Write to the data point
caller.term()
"""

# %%
if __name__ == '__main__':
    ddf = createDDF("BZ172Lab Status Variables.CSV",
                    "E2PROM Parameters.CSV")
    createbzMBDevice_BZ172Lab(ddf)

