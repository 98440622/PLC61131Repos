"""
The main purpose of having this simple script is to be more familiar with data
processing with pandas and the side effect is having a 'tool' to convert the
two DDF files generated by M172 IDE into one modbus register map file by csv
format which is easy to be imported in excel.

Version MY_VERSION

2021.02.17 First created
2021.02.21 Create separate files for register map doc and code generation
2021.02.27 Add the data points accessor to the target device
2021.02.28 New verison of c file generation
2021.03.01 Implementation of the six data point representors
           Improve the C files by adding comments
           Addresses the issues in the C files that cause failure of modbus
           polling
2021.03.02 Add a script as an example for auto testing
2021.03.04 Generate two DDF.csv files, one for user and the other is a complete
           version
2021.03.05 Add 'reset' interface
2021.03.06 Add 'createbzAisleACUnit_py' to create application class for data
           point quick access

"""

import pandas as pd
from ctypes import *
import os
from datetime import datetime
import time

MY_VERSION = '21MAR03'

def createDDF(variable_filename, e2prom_filename) :
    '''
    Parameters
    ----------
    variable_filename : TYPE
        DESCRIPTION.
    e2prom_filename : TYPE
        DESCRIPTION.

    Returns
    -------
    None.

    '''
    # load sheets
    dfVariables = pd.read_csv(variable_filename,
                              encoding='ansi',
                              dtype=str,
                              delimiter=',',
                              usecols=[0, 1, 3, 5, 6, 7, 8, 11, 14, 15, 16])
    dfConfigurations = pd.read_csv(e2prom_filename,
                                   encoding='ansi',
                                   dtype=str,
                                   usecols=[0, 1, 3, 5, 6, 7, 8, 11, 14, 15])

    # Add 'RW' to dfConfigurations
    ReadOnly = ['RW'] * len(dfConfigurations)
    dfConfigurations.insert(loc=9, column='ReadOnly', value=ReadOnly)

    # Combine the two dataframes and replace 'na' with blank
    ddf = pd.concat([dfVariables, dfConfigurations])
    ddf = ddf.fillna('')

    # Fill the 'Size' of 16bit items with '1'
    ddf.loc[ddf['Size'] == '', 'Size'] = '1'

    # Remove 'bz' and 'Cfg' from names
    ddf.Name = ddf.Name.str.replace('bz', '')
    ddf.Min = ddf.Min.str.replace('bz', '')
    ddf.Max = ddf.Max.str.replace('bz', '')

    # Sort by address
    ddf.loc[:, 'Address'] = ddf.Address.astype('ushort')
    ddf = ddf.sort_values(by='Address', ascending=True)

    # Update column names
    ddf.columns = ['Address', 'DataPoint', 'Type', 'Size', 'Default', 'Min',
                   'Max', 'Unit', 'RW', 'Description', 'Note']

    # Update index
    ddf.index=[x for x in range(1, len(ddf) + 1)]

    # Remove 'BZ...' items for customer version
    ddf_copy = ddf.drop(index=ddf[ddf['DataPoint'].str.match('BZ')].index)

    # save to csv file with utf-8 format by default
    ddf.to_csv('BZ172LabDDF.csv', index_label='NO')
    ddf_copy.to_csv('BZ172LabDDF2MBs.csv', index_label='NO')

    return ddf;

def createbzMBDevice_BZ172Lab(ddf) :
    '''
    Parameters
    ----------
    None.

    Returns
    -------
    None.

    '''
    with open("bzMBDevice_BZ172Lab.h", "w") as file:
        strContent = """
/**
 * This file is generated by BZ172Lab.py ({0}) according to the DDF file.
 *
 * DON'T CHANGE IT MANUALLY!
 *
 * {1} created.
 */
#ifndef _BZMBDEVICE_BZ172LAB_H_
#define _BZMBDEVICE_BZ172LAB_H_

#ifdef __cplusplus
extern "C" {{
#endif // __cplusplus

#include "bzObject.h"
#include "bzMBDevice.h"

typedef struct _tagMBBZ172LabVariables {{

""".format(MY_VERSION, str(datetime.now()))
        for i in range(0, len(ddf) - 1):
            if (ddf.Type.iloc[i] == 'Signed 16-bit') :
                strContent += '    /*{0:03d}*/bzI16 '.format(i) + ddf.DataPoint.iloc[i] + '[1];'
            elif (ddf.Type.iloc[i] == 'Unsigned 16-bit'):
                strContent += '    /*{0:03d}*/bzU16 '.format(i) + ddf.DataPoint.iloc[i] + '[1];'
            elif (ddf.Type.iloc[i] == 'String') :
                max_len = int(int(ddf.Size.iloc[i]) / 2)
                #if (max_len % 2) :
                #    max_len += 1
                #else :
                #    max_len += 2
                strContent += str('    /*{0:03d}*/bzU8  ' + ddf.DataPoint.iloc[i] +
                              '[{1}];').format(i, max_len)
            else:
                pass
            if (ddf.Type.iloc[i] == 'String'):
                strContent += '// Max string length is ' + str(max_len) + '\n'
            else:
                if (ddf.Unit.iloc[i] == ''):
                    strContent += '// ' + ddf.Note.iloc[i] + '\n'
                else:
                    strContent += '// ' + ddf.Unit.iloc[i] + '\n'

        strContent += """
} MBBZ172LabVariables;
"""

        strContent += '\n#define MAX_BZ172LAB_MB_REGISTERS {0}\n'.format(len(ddf))

        strContent += """
typedef void (*BZ172LabDatapointRepresentor) (bzR32* /*rval*/,
                                              bzBool /*from_reg*/,
                                              bzU16* /*reg*/,
                                              bzU8 /*len*/);

typedef struct _tagMBBZ172LabDevice {
    MBBZ172LabVariables             MBVariables;
    bzModbusRegister                MBRegisters[MAX_BZ172LAB_MB_REGISTERS];
    BZ172LabDatapointRepresentor    Representors[MAX_BZ172LAB_MB_REGISTERS];
    bzModbusDevice                  Dev;
} MBBZ172LabDevice;

_public_ void MBBZ172LabDevice_ctor(MBBZ172LabDevice*, bzU8);
_public_ void MBBZ172LabDevice_dtor(MBBZ172LabDevice*);


#ifdef __cplusplus
}
#endif

#endif  // _BZMBDEVICE_BZ172LAB_H_

"""
        file.write(strContent)
        file.close()

    with open("bzMBDevice_BZ172Lab.c", "w") as file:
        strRepresentorList = ["MBBZ172LabDevice_bzU16_1_scaled_cov",    # 0
                              "MBBZ172LabDevice_bzU16_10_scaled_cov",   # 1
                              "MBBZ172LabDevice_bzU16_100_scaled_cov",  # 2
                              "MBBZ172LabDevice_bzi16_1_scaled_cov",    # 3
                              "MBBZ172LabDevice_bzi16_10_scaled_cov",   # 4
                              "MBBZ172LabDevice_bzi16_100_scaled_cov"]  # 5
        strContent = """
/**
 * This file is generated by BZ172Lab.py ({0}) according to the DDF file.
 *
 * DON'T CHANGE IT MANUALLY!
 *
 * {1} created.
 */
#include "bzMBDevice_BZ172Lab.h"

void {2}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = (bzR32)regs[0];
    }} else {{
        regs[0] = (bzU16)(*lpRval);
    }}
}}
void {3}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = ((bzR32)regs[0]) / (bzR32)10.0;
    }} else {{
        regs[0] = (bzU16)((*lpRval) * (bzR32)10.0);
    }}
}}
void {4}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = ((bzR32)regs[0]) / (bzR32)100.0;
    }} else {{
        regs[0] = (bzU16)((*lpRval) * (bzR32)100.0);
    }}
}}
void {5}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = (bzR32)((bzI16)regs[0]);
    }} else {{
        regs[0] = (bzI16)(*lpRval);
    }}
}}
void {6}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = ((bzR32)((bzI16)regs[0])) / (bzR32)10.0;
    }} else {{
        regs[0] = (bzI16)((*lpRval) * (bzR32)10.0);
    }}
}}
void {7}(bzR32* lpRval, bzBool from_reg, bzU16* regs, bzU8 len) {{
    if (from_reg) {{
        *lpRval = ((bzR32)((bzI16)regs[0])) / (bzR32)100.0;
    }} else {{
        regs[0] = (bzI16)((*lpRval) * (bzR32)100.0);
    }}
}}

_public_ void MBBZ172LabDevice_ctor(MBBZ172LabDevice* me, bzU8 id) {{
""".format(MY_VERSION,
           str(datetime.now()),
           strRepresentorList[0],
           strRepresentorList[1],
           strRepresentorList[2],
           strRepresentorList[3],
           strRepresentorList[4],
           strRepresentorList[5])
        for i in range(0, len(ddf) - 1):
            if (ddf.Type.iloc[i] == 'String') :
                sz = int(int(ddf.Size.iloc[i]) / 2)
                #if (sz % 2) :
                #    sz += 1
                #else :
                #    sz += 2
                #sz /= 2
            else:
                sz = 1
            strLn = '    bzModbusRegister_new(me->MBRegisters[{0}], '\
                    'bzBusProtocol_MB_HoldingRegister, {1}, {2}, '\
                    'me->MBVariables.{3});\n'.format(i,
                                                     int(ddf.Address.iloc[i]) - 1,
                                                     int(sz),
                                                     ddf.DataPoint.iloc[i])
            strContent += strLn

            strType = ddf.Type.iloc[i]
            strScale = ddf.Unit.iloc[i]
            if (strType == 'String'):
                strRepresentor = 'bzNull'
            elif (strType == 'Signed 16-bit'):
                if (strScale.find('.1') >= 0):
                    strRepresentor = strRepresentorList[4]
                elif (strScale.find('.01') >= 0):
                    strRepresentor = strRepresentorList[5]
                else:
                    strRepresentor = strRepresentorList[3]
            elif (strType == 'Unsigned 16-bit'):
                if (strScale.find('.1') >= 0):
                    strRepresentor = strRepresentorList[1]
                elif (strScale.find('.01') >= 0):
                    strRepresentor = strRepresentorList[2]
                else:
                    strRepresentor = strRepresentorList[0]
            else:
                pass
            strLn = '    me->Representors[{0}] = {1};\n\n'.format(i,
                                                                  strRepresentor)
            strContent += strLn

        strContent += """

    bzModbusDevice_ctor(&me->Dev, id);

    me->Dev.Registers = me->MBRegisters;
    me->Dev.NumberOfRegisters = MAX_BZ172LAB_MB_REGISTERS;
}

_public_ void MBBZ172LabDevice_dtor(MBBZ172LabDevice* me) {}
"""
        file.write(strContent)
        file.close()

def createbzAisleACUnit_py(ddf) :
    """
    Create data point quick access module according to the DDF file

    Parameters
    ----------
    ddf : TYPE
        DESCRIPTION.

    Returns
    -------
    None.

    """
    strSTRFunc = """
    def $DATAPOINT$(self, *args):
        if (args == ()):
            rtn, val = self.caller.getStr($ID$)
            return [rtn, val][rtn == 0]
        else:
            rtn = self.caller.setStr($ID$, args[0])
            return rtn
"""

    strVARFunc = """
    def $DATAPOINT$(self, *args):
        if (args == ()):
            rtn, val = self.caller.getVar($ID$)
            return [rtn, $TYPE$(val)][rtn == 0]
        else:
            rtn = self.caller.setVar($ID$, args[0])
            return rtn
"""
    with open("bzAisleACUnit.py", "w") as file:
        strContent = """
# -*- coding: utf-8 -*-
\"""
The functions in this module is kind of a shortcut for the interaction with
the data points in bzAisleACUnit application. Refer to the samples in BZ172Lab
as a user guide. This file is generated from the DDF file, do DO NOT MAKE ANY
MODIFICATION!

{1} generated by {0}(BZ172Lab.py) version
\"""

from BZ172Lab import *
""".format(MY_VERSION,
           str(datetime.now()))

        strContent += """
class bzAisleACUnit :
    def __init__(self):
        self.caller = IrACdx36LibCaller()
        self.caller.init()

"""

        for i in range(0, len(ddf) - 1):
            if (ddf.Type.iloc[i] == 'String') :
                strLn = strSTRFunc
            else:
                strLn = strVARFunc
                if (ddf.Unit.iloc[i].find('.1') >= 0 or
                    ddf.Unit.iloc[i].find('.01') >= 0):
                    strLn = strLn.replace('$TYPE$', 'float')
                else:
                    strLn = strLn.replace('$TYPE$', 'int')
            strLn = strLn.replace('$DATAPOINT$', ddf.DataPoint.iloc[i])
            strLn = strLn.replace('$ID$', str(int(ddf.index[i]) - 1))
            strLn += '\n'

            strContent += strLn

        file.write(strContent)
        file.close()

class IrACdx36LibCaller :
    """
    A 'c' functions wrapper as the data points accessor
    """
    def __init__(self):
        self.clib = CDLL(os.getcwd() + '\\IrACdx36Libx64.dll')

        self.clib.IRAC_Initialize.argtypes = []
        self.clib.IRAC_Initialize.restype = c_int
        self.Init = self.clib.IRAC_Initialize

        self.clib.IRAC_Terminate.argtypes = []
        self.clib.IRAC_Terminate.restype = c_int
        self.Term = self.clib.IRAC_Terminate

        self.clib.IRAC_BZ172Lab_PollVariable.argtypes = [c_int, c_int, POINTER(c_float)]
        self.clib.IRAC_BZ172Lab_PollVariable.restype = c_int
        self.pollVariable = self.clib.IRAC_BZ172Lab_PollVariable

        self.clib.IRAC_BZ172Lab_PollString.argtypes = [c_int, c_int, POINTER(c_char), c_int]
        self.clib.IRAC_BZ172Lab_PollString.restype = c_int
        self.pollString = self.clib.IRAC_BZ172Lab_PollString

        self.clib.IRAC_BZ172Lab_Reset.argtypes = []
        self.clib.IRAC_BZ172Lab_Reset.restype = c_int
        self.reset = self.clib.IRAC_BZ172Lab_Reset

    def init(self):
        rtn = self.Init()
        if (rtn == 0):
            print(':~) Connected to data point agent')
        else:
            print(':-( Fail to connect data point agent {0}'.format(rtn))
        return rtn

    def term(self):
        return self.Term()

    def getVar(self, id):
        val = c_float()
        rtn = self.pollVariable(id, 1, pointer(val))
        return rtn, val.value;

    def setVar(self, id, val):
        rval = c_float()
        rval.value = val;
        rtn = self.pollVariable(id, 0, pointer(rval))
        return rtn;

    def getStr(self, id):
        lpstr = create_string_buffer(b'\0', 256)
        rtn = self.pollString(id, 1, lpstr, 256)
        return rtn, lpstr.value.decode('utf-8')

    def setStr(self, id, text):
        lpstr = create_string_buffer(b'\0', 256)
        lpstr.value = text.encode('utf-8')
        rtn = self.pollString(id, 0, lpstr, 256)
        return rtn;

    def getVars(self, ids):
        res = []
        for id in ids:
            res.append(self.getVar(id))
        return res

# %% bzAisleACUnit test cases
"""
TODO : Add my test cases
Useage :

    mytest = bzAisleACUnitTestAgent()
    mytest.testcase1()
    ...
    mytest.testcase2()

"""
from bzAisleACUnit import *

class bzAisleACUnitTestAgent:
    def __init__(self):
        self.unit = bzAisleACUnit()

    def checkFMVersion(self):
        print(self.unit.BIOSVersion())
        print(self.unit.AppVersion())

    def checkAmibentTemperatures(self):
        print(self.unit.UpperReturnAirTemperature())

# %% (OBSOLETE) Solo is what i want
class BZ172Lab :
    def __init__(self):
        self.caller = IrACdx36LibCaller()

        self.IDandVars = pd.read_csv('BZ172LabDDF.csv', usecols=[0, 2])
        self.IDandVars.NO = self.IDandVars.NO - 1

        self.BIOSVersionID,\
        self.AppVersionID = [
            self.IDandVars.NO[self.IDandVars.DataPoint == 'BIOSVersion'],
            self.IDandVars.NO[self.IDandVars.DataPoint == 'AppVersion']]
        self.BZIsRealModeID = \
            self.IDandVars.NO[self.IDandVars.DataPoint == 'BZIsRealMode']

        self.BZDILnID = [x for x in range(84, 96)]
        self.BZAILnID = [x for x in range(96, 108)]

        self.AmbientTemperaturesID = [x for x in range(2, 11)]

        self.WarningIDs = [x for x in range(38, 66)] # 65 is the last one
        self.AlarmIDs = [x for x in range(66, 77)]

        self.ActuatorIDs = [x for x in range(12, 20)]

        if (self.caller.init() != 0):
            print("Activate IrACdx36 firstly.")
        else:
            var = self.caller.getVar(self.BZIsRealModeID)
            if (var[0] != 0):
                print("IrACdx36 cannot connect to target.")
            else:
                print("GOOD to go with {0} mode".format(
                    ['REAL', 'SOLO'][int(var[1]) == 0]))
                # ['true', 'false'][True]  'false'

        print("BIOS         : ",
              (self.caller.getStr(self.BIOSVersionID)[1]))
        print("APPLICATION  : ",
              (self.caller.getStr(self.AppVersionID)[1]))

    def __del__(self):
        #self.caller.term()
        pass

    def checkVars(self, ids):
        if (type(ids) == int):
            res = self.caller.getVar(ids)
            print("{0}({2})={1}".format(self.IDandVars.DataPoint[ids],
                                        res[1],
                                        ids))
        else:
            tmps = self.caller.getVars(ids)
            for i, k in zip(ids, range(0, len(ids))):
                print("{0}({1}) = {2}".format(self.IDandVars.DataPoint[i],
                                              k,
                                              tmps[k][1]))

    def updateVar(self, i, v):
        if (i in self.IDandVars.NO):
            self.caller.setVar(i, v)
        else:
            print(i, ' is out of boundary')

    def goSolo(self):
        var = self.caller.getVar(self.BZIsRealModeID)
        if (int(var[0]) != 0):
            print("Lost target!")
        else:
            if (int(var[1]) == 1):
                #print("Set target in solo mode")
                self.caller.setVar(self.BZIsRealModeID, 0)
                input("Cycle the power of the target and "
                      "press any key after it reboot...")
                self.caller.reset()
            else:
                pass

            for i in self.BZAILnID:
                self.caller.setVar(i, 220)

            print("Solo is my desire.")

    def setAI(self, i, v):
        if (i in self.BZAILnID):
            self.caller.setVar(i, v)
        else:
            print(i, " is not for AI index")

    def toggleDI(self, i):
        if (i in self.BZDILnID):
            self.caller.setVar(i, [1, 0][self.caller.getVar(i)[1] == 0])

    def checkAmbient(self):
        tmps = self.caller.getVars(self.AmbientTemperaturesID)
        for i, k in zip(self.AmbientTemperaturesID,
                        range(0, len(self.AmbientTemperaturesID))):
            print("{0}({2}) = {1:.01f}".format(self.IDandVars.DataPoint[i],
                                          tmps[k][1],
                                          k))

    def checkWarnings(self):
        tmps = self.caller.getVars(self.WarningIDs)
        for i, k in zip(self.WarningIDs, range(0, len(self.WarningIDs))):
            print("{0} = {1}".format(self.IDandVars.DataPoint[i],
                                     ['NO', 'YES'][int(tmps[k][1])],
                                     k))

    def checkAlarms(self):
        tmps = self.caller.getVars(self.AlarmIDs)
        for i, k in zip(self.AlarmIDs, range(0, len(self.AlarmIDs))):
            print("{0} = {1}".format(self.IDandVars.DataPoint[i],
                                     ['NO', 'YES'][int(tmps[k][1])],
                                     k))

    def checkActuators(self):
        self.checkVars(self.ActuatorIDs)

# %% (OBSOLETE) an example of how to use a script to run an auto testing
def sample_1():
    RATavg, SATavg, RACmax, Unitst, Unitcmd, Coolsp, SATsp, Fanstg = \
        [4,      7,     10,     12,      80,     81,    83,     97]
    EvapFancmd, EXVcmd, Compcmd, Compspd = \
        [   13,     14,      15,      19]

    caller.init()

    print("TEST CASE 1. Cooling function verification")

    print("Step 1. check ambient temperature")
    print("Average supply air temperature is ", caller.getVar(SATavg)[1])
    print("Average return air temperature is ", caller.getVar(RATavg)[1])
    print("Max rack inlet temperature is ", caller.getVar(RACmax)[1])

    print("Step 2. make sure the set points can meet the requirements")
    print("Supply air setpoint is 15.0")
    caller.setVar(SATsp, 15.0)
    print("Fan strategy is 0 (inrow)")
    caller.setVar(Fanstg, 0)
    print("Cool setpoint is 18.0")
    caller.setVar(Coolsp, 18.0)

    print("Step 3. set unit on (1)")
    caller.setVar(Unitcmd, 1)
    time.sleep(1) # wait for 1 second
    print("<<{0}>> - Unit status is ON?".format(
        caller.getVar(Unitst) == (0, 2)))

    time.sleep(5)
    print("Step 4. check actuators")
    print("<<{0}>> - Evaporator fan is started?".format(
        caller.getVar(EvapFancmd)[1] > 0))
    print("<<{0}>> - EXV is opened?".format(
        caller.getVar(EXVcmd)[1] > 0))
    print("Wait for 10 seconds...")
    time.sleep(10)
    print("<<{0}>> - Compressor is started?".format(
        caller.getVar(Compcmd)[1] > 0))

    print("Step 5. check compressor upload")
    comp_spd = caller.getVar(Compcmd)[1]
    print("Compressor current speed ", comp_spd)
    print("Wait for 20 second...")
    time.sleep(20)
    print("<<{0}>> - Now the compressor speed is increased?".format(
        caller.getVar(Compcmd)[1] > comp_spd))

    print("Step 6. set unit off")
    caller.setVar(Unitcmd, 0)
    print("Wait for 10 seconds...")
    time.sleep(10)
    print("<<{0}>> - All actuators are off".format(
        caller.getVar(EvapFancmd)[1] == 0 and
        caller.getVar(EXVcmd)[1] == 0) and
        caller.getVar(Compcmd)[1] == 0)

    print("END OF TEST CASE 1")

    caller.term()
    print("Disconnect from data point agent")

# %% main entry
if __name__ == '__main__':
    ddf = createDDF("BZ172Lab Status Variables.CSV",
                    "E2PROM Parameters.CSV")
    createbzMBDevice_BZ172Lab(ddf)
    createbzAisleACUnit_py(ddf)

